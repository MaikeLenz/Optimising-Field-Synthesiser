import numpy as np
import scipy.signal as signal

def totalPower(t, E, window=[0,0]):
    """
    Integrates the field using trapezium rule.
    t: List of times
    E: List of E generated by simulation
    window: Time window to integrate over
    """
    t_crop = []
    I_crop = []
    for i in range(len(t)):
        if t[i] >= window[0] and t[i] <= window[1]:
            t_crop.append(t[i])
            I_crop.append(E[i]**2)
    
    h = t_crop[1] - t_crop[0]
    return 0.5*h*((I_crop[0]+I_crop[-1]) + 2*np.sum(I_crop[1:-1]))

def slopeGradient(t, E, window=[0,0]):
    # Not sure this will work since cos field inside
    """
    Calculates the maximum gradient of the E field.
    t: List of times
    E: List of E generated by simulation
    window: Time window to investigate
    """
    t_crop = []
    E_crop = []
    for i in range(len(t)):
        if t[i] >= window[0] and t[i] <= window[1]:
            t_crop.append(t[i])
            E_crop.append(E[i])   
       
    diff = np.zeros(len(E_crop[1:]))
    for i in len(range(E_crop[1:])):
        diff[i] = abs(E_crop[i] - E_crop[i-1])
    return max(diff)

def sharpestPeak(t, E, window=[0,0], widths=50):
    """
    Calculates the maximum gradient of the E field.
    t: List of times
    E: List of E generated by simulation
    window: Time window to investigate
    widths: number of points expected in a peak
    """
    t_crop = []
    E_crop = []
    for i in range(len(t)):
        if t[i] >= window[0] and t[i] <= window[1]:
            t_crop.append(t[i])
            E_crop.append(E[i]) 
    
    indices = signal.find_peaks_cwt(E_crop, (widths,widths))
    prominences = signal.peak_prominences(E_crop, indices)[0]
    peakwidths = signal.peak_widths(E_crop, indices, prominence_data=prominences)[0]
    
    ratios = np.zeros(len(indices))
    for i in range(len(indices)):
        ratios[i] = prominences[i]/peakwidths[i]
        
    return max(ratios)
