import numpy as np
import scipy.signal as signal
#defines sub-target functions which are used to define the target function in bossfunction file.

def totalPower(t, E):
    """
    Integrates the field using trapezium rule.
    t: array of times
    E: array of E field generated by simulation
    window: Time window to integrate over
    """
    I=[]
    for i in E:
        I.append(i**2)
    h = t[1] - t[0]
    return 0.5*h*((I[0]+I[-1]) + 2*np.sum(I[1:-1]))

def maxIntens(t,E):
    """
    returns the maximum intensity value
    t: array of times
    E: array of E field generated by simulation
    """
    I=[]
    for i in E:
        I.append(i**2)
    return max(I)

def slopeGradient(t,E):
    # Not sure this will work since cos field inside
    """
    Calculates the maximum gradient of the E field based the difference between consecutive values.
    t: List of times
    E: List of E generated by simulation
    window: Time window to investigate
    """
    I=[]
    for i in E:
        I.append(i**2)
    diff = np.zeros(len(I[1:]))
    for i in range(len(I)-1):
        diff[i] = I[i] - I[i-1]
    return max(diff)

def sharpestPeak(t,E, widths=5): #not working since scipy doesnt always pick up on the peaks
    """
    Calculates the sharpest intensity peak with scipy peak functions.
    t: List of times
    E: List of E generated by simulation
    window: Time window to investigate
    widths: number of points expected in a peak
    """
    I=[]
    for i in E:
        I.append(i**2)
    indices = signal.find_peaks_cwt(I, (widths,widths))
    prominencestotal = signal.peak_prominences(I, indices)
    prominences=prominencestotal[0]
    peakwidths = signal.peak_widths(I, indices, prominence_data=prominencestotal)[0]
    #peakwidths = signal.peak_widths(I, indices)[0]


    ratios = np.zeros(len(indices))
    for i in range(len(indices)):
        ratios[i] = prominences[i]/peakwidths[i]
        
    return max(ratios)


def sharpestPeak_triang(t,E, widths=5):
    """
    calculates difference between peak and two values before & after it
    t: array of times
    E: array of E field generated by simulation
    if this value is large, the peak is sharp
    """
    I=[]
    for i in E:
        I.append(i**2)
    indices = signal.find_peaks_cwt(I, (widths,widths))
    differences=[]
    for index in indices:
        if index > 2 and index < (len(E)-10): #this excludes sharp peaks near the edge of our window
            differences.append(2*I[index]-I[index-10]-I[index+10])
    return max(differences)