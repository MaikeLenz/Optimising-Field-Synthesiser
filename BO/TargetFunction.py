import numpy as np
import scipy.signal as signal

def totalPower(t, E):
    """
    Integrates the field using trapezium rule.
    t: List of times
    E: List of E generated by simulation
    window: Time window to integrate over
    """
    I=[]
    for i in E:
        I.append(i**2)
    h = t[1] - t[0]
    return 0.5*h*((I[0]+I[-1]) + 2*np.sum(I[1:-1]))

def slopeGradient(t,E):
    # Not sure this will work since cos field inside
    """
    Calculates the maximum gradient of the E field.
    t: List of times
    E: List of E generated by simulation
    window: Time window to investigate
    """
    I=[]
    for i in E:
        I.append(i**2)
    diff = np.zeros(len(I[1:]))
    for i in range(len(I)-1):
        diff[i] = I[i] - I[i-1]
    return max(diff)

def sharpestPeakt(t,E, widths=5):
    """
    Calculates the maximum gradient of the E field.
    t: List of times
    E: List of E generated by simulation
    window: Time window to investigate
    widths: number of points expected in a peak
    """
    I=[]
    for i in E:
        I.append(i**2)
    indices = signal.find_peaks_cwt(I, (widths,widths))
    prominencestotal = signal.peak_prominences(I, indices)
    prominences=prominencestotal[0]
    peakwidths = signal.peak_widths(I, indices, prominence_data=prominencestotal)[0]
    #peakwidths = signal.peak_widths(I, indices)[0]


    ratios = np.zeros(len(indices))
    for i in range(len(indices)):
        ratios[i] = prominences[i]/peakwidths[i]
        
    return max(ratios)
    #return -1*min(peakwidths)


def sharpestPeak_triang(t,E, widths=5):
    """
    calculates difference between peak and its two neighbours
    """
    I=[]
    for i in E:
        I.append(i**2)
    indices = signal.find_peaks_cwt(I, (widths,widths))
    differences=[]
    for index in indices:
        if index > 10 and index < (len(E)-10): #this excludes sharp peaks near the edge of our window
            differences.append(2*I[index]-I[index-10]-I[index+10])
    return max(differences)